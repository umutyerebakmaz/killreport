# 🏗️ MODULAR RESOLVER STRUCTURE - DETAILED EXPLANATION

## 📁 Project Structure

```
backend/
├── src/
│   ├── schema/                    # GraphQL Schema Files (SDL)
│   │   ├── user.graphql           # User domain schema
│   │   ├── character.graphql      # Character domain schema
│   │   └── killmail.graphql       # Killmail domain schema
│   │
│   ├── resolvers/                 # Resolver Implementations
│   │   ├── index.ts               # 🔥 Main file combining all resolvers
│   │   ├── user.resolver.ts       # User resolvers (Query + Mutation)
│   │   ├── character.resolver.ts  # Character resolvers + Field resolvers
│   │   └── killmail.resolver.ts   # Killmail resolvers
│   │
│   ├── generated-types.ts         # 🤖 Types automatically generated by CodeGen
│   ├── generated-schema.graphql   # 🤖 Merged GraphQL schema
│   └── server.ts                  # GraphQL Yoga server
│
├── codegen.ts                     # GraphQL Code Generator configuration
├── package.json
└── TEST_QUERIES.md                # Test queries

🤖 = Automatically generated files (do not edit manually!)
🔥 = Critical file
```

---

## 🔄 WORKFLOW STEP BY STEP

### **STEP 1: Schema Definition (Domain-Based)**

Create a separate `.graphql` file for each domain:

#### **user.graphql**

```graphql
type Query {
  user(id: ID!): User
  users: [User!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User
}

type User {
  id: ID!
  name: String!
  email: String!
}
```

#### **character.graphql** (using extend)

```graphql
extend type Query { # ⚠️ "extend" keyword!
  character(id: ID!): Character
}

extend type Mutation {
  addCharacter(input: AddCharacterInput!): Character!
}

type Character {
  id: ID!
  name: String!
  user: User # Relation field
}
```

**💡 Why use `extend`?**

- To define the same type in multiple files
- Each domain can add its own Query/Mutation
- Merges without conflict

---

### **STEP 2: Code Generation**

```bash
yarn codegen
```

**What happens?**

1. Reads the `codegen.ts` configuration
2. Finds all `src/schema/**/*.graphql` files
3. Merges all schemas → `generated-schema.graphql`
4. Generates TypeScript types → `generated-types.ts`

**Important Generated Types:**

```typescript
// generated-types.ts

export type QueryResolvers = {
  user?: Resolver<...>;
  users?: Resolver<...>;
  character?: Resolver<...>;
  charactersByUser?: Resolver<...>;
  killmail?: Resolver<...>;
  killmails?: Resolver<...>;
};

export type MutationResolvers = {
  createUser?: Resolver<...>;
  updateUser?: Resolver<...>;
  addCharacter?: Resolver<...>;
};

export type CharacterResolvers = {
  user?: Resolver<...>;  // Field resolver
};
```

---

### **STEP 3: Modular Resolver Implementation**

A separate resolver file for each domain:

#### **user.resolver.ts**

```typescript
import { QueryResolvers, MutationResolvers } from "../generated-types";

// Query Resolvers - Exported
export const userQueries: QueryResolvers = {
  user: (_, { id }) => {
    // Fetch user from database
    return findUserById(id);
  },
  users: () => {
    // Fetch all users
    return findAllUsers();
  },
};

// Mutation Resolvers - Exported
export const userMutations: MutationResolvers = {
  createUser: (_, { input }) => {
    // Create new user
    return createNewUser(input);
  },
  updateUser: (_, { id, input }) => {
    // Update user
    return updateExistingUser(id, input);
  },
};
```

**💡 Advantages:**

- ✅ Each domain in its own file (ideal 50-200 lines)
- ✅ Type-safe (TypeScript auto-completion)
- ✅ Testable (each resolver exported separately)
- ✅ Very low risk of merge conflict (work in different files)

---

#### **character.resolver.ts** (With Field Resolvers)

```typescript
import {
  QueryResolvers,
  MutationResolvers,
  CharacterResolvers,
} from "../generated-types";

export const characterQueries: QueryResolvers = {
  character: (_, { id }) => {
    return findCharacterById(id);
  },
};

export const characterMutations: MutationResolvers = {
  addCharacter: (_, { input }) => {
    return createCharacter(input);
  },
};

// 🔥 FIELD RESOLVER - For nested fields
export const characterFieldResolvers: CharacterResolvers = {
  // Runs when Character.user field is called
  user: (parent) => {
    // parent = Character object
    return findUserById(parent.userId);
  },
};
```

**💡 What is a Field Resolver?**

Query:

```graphql
query {
  character(id: "1") {
    id
    name
    user {
      # ← When this field is called
      name #   characterFieldResolvers.user runs
      email
    }
  }
}
```

Flow:

1. `characterQueries.character` → Returns Character
2. GraphQL sees the `user` field
3. `characterFieldResolvers.user(parent)` is called
4. Fetches User with userId from parent

---

### **STEP 4: Combining Resolvers**

#### **resolvers/index.ts** (Main Combining File)

```typescript
import { Resolvers } from "../generated-types";
import { userQueries, userMutations } from "./user.resolver";
import {
  characterQueries,
  characterMutations,
  characterFieldResolvers,
} from "./character.resolver";
import { killmailQueries } from "./killmail.resolver";

export const resolvers: Resolvers = {
  Query: {
    // Combine all domain queries
    ...userQueries,
    ...characterQueries,
    ...killmailQueries,
  },

  Mutation: {
    // Combine all domain mutations
    ...userMutations,
    ...characterMutations,
  },

  // Field Resolvers
  Character: characterFieldResolvers,
};
```

**💡 Using the Spread Operator (`...`):**

These two codes are the same:

```typescript
// Manual
Query: {
  user: userQueries.user,
  users: userQueries.users,
  character: characterQueries.character,
}

// With spread
Query: {
  ...userQueries,
  ...characterQueries,
}
```

---

### **STEP 5: Connecting to the Server**

#### **server.ts**

```typescript
import { resolvers } from "./resolvers"; // Comes from index.ts

const schema = makeExecutableSchema({
  typeDefs, // Merged from all .graphql files
  resolvers, // From resolvers/index.ts
});

const yoga = createYoga({ schema });
```

---

## ⚙️ ADDING A NEW DOMAIN

Example: Let's add a **Post** domain

### 1. Create Schema

**schema/post.graphql**

```graphql
extend type Query {
  post(id: ID!): Post
  posts: [Post!]!
}

extend type Mutation {
  createPost(input: CreatePostInput!): Post!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User # Relation
}

input CreatePostInput {
  title: String!
  content: String!
  authorId: ID!
}
```

### 2. Run CodeGen

```bash
yarn codegen
```

### 3. Create Resolver

**resolvers/post.resolver.ts**

```typescript
import {
  QueryResolvers,
  MutationResolvers,
  PostResolvers,
} from "../generated-types";

export const postQueries: QueryResolvers = {
  post: (_, { id }) => findPostById(id),
  posts: () => findAllPosts(),
};

export const postMutations: MutationResolvers = {
  createPost: (_, { input }) => createNewPost(input),
};

export const postFieldResolvers: PostResolvers = {
  author: (parent) => findUserById(parent.authorId),
};
```

### 4. Add to Index

**resolvers/index.ts**

```typescript
import {
  postQueries,
  postMutations,
  postFieldResolvers,
} from "./post.resolver";

export const resolvers: Resolvers = {
  Query: {
    ...userQueries,
    ...characterQueries,
    ...killmailQueries,
    ...postQueries, // ← Newly added
  },

  Mutation: {
    ...userMutations,
    ...characterMutations,
    ...postMutations, // ← Newly added
  },

  Character: characterFieldResolvers,
  Post: postFieldResolvers, // ← Newly added
};
```

### 5. Restart the Server

```bash
yarn dev
```

✅ New domain is ready! Without breaking any existing files.

---

## 🎯 BEST PRACTICES

### ✅ DO

1. **Separate file for each domain:**

   - `user.graphql` + `user.resolver.ts`
   - `character.graphql` + `character.resolver.ts`

2. **Small, focused resolvers:**

   - Each resolver does one thing
   - 50-200 lines is ideal

3. **Use field resolvers:**

   - For nested data (solve N+1 query with DataLoader)

4. **Maintain type safety:**

   - Import from `generated-types.ts`
   - Do not use `any`

5. **Use spread operator:**
   - `...userQueries` for clean code

### ❌ DON'T

1. **Don't use a single resolver.ts:**

   - 1000+ line files are unreadable

2. **Don't edit generated-\*.ts files:**

   - CodeGen will overwrite every time

3. **Don't define schema in TypeScript:**

   - Use SDL (`.graphql`), it's more readable

4. **Don't forget field resolvers:**
   - Important for relations

---

## 🚀 PERFORMANCE TIPS

### N+1 Query Problem

**Bad Example:**

```typescript
Character: {
  user: (parent) => {
    // Separate query for each character!
    return db.user.findById(parent.userId); // ❌ N+1 problem
  };
}
```

**Good Example (with DataLoader):**

```typescript
import DataLoader from "dataloader";

const userLoader = new DataLoader((ids) =>
  db.user.findMany({ where: { id: { in: ids } } })
);

Character: {
  user: (parent) => {
    return userLoader.load(parent.userId); // ✅ Batch query
  };
}
```

---

## 📊 FILE SIZE COMPARISON

### Single File Approach ❌

```
resolvers.ts → 2500 lines
schema.graphql → 800 lines
```

- Hard to read
- High risk of merge conflict
- Hard to test

### Modular Approach ✅

```
user.graphql → 50 lines
user.resolver.ts → 80 lines

character.graphql → 60 lines
character.resolver.ts → 100 lines

killmail.graphql → 70 lines
killmail.resolver.ts → 120 lines

index.ts → 40 lines
```

- Easy to read
- Low risk of merge conflict
- Easy to test
- Efficient teamwork

---

## 🔍 SUMMARY OF THE SUMMARY

1. **Schemas → Separate by domain** (user.graphql, character.graphql)
2. **Resolvers → Separate by domain** (user.resolver.ts, character.resolver.ts)
3. **Run CodeGen** → Generate type-safe types
4. **resolvers/index.ts → Combine everything**
5. **server.ts → Schema + Resolver → GraphQL Yoga**

**Result:** Scalable, maintainable, type-safe GraphQL API! 🎉
