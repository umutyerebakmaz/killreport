# ğŸ—ï¸ MODULAR RESOLVER STRUCTURE - DETAILED EXPLANATION

## ğŸ“ Project Structure

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ schema/                    # GraphQL Schema Files (SDL)
â”‚   â”‚   â”œâ”€â”€ user.graphql           # User domain schema
â”‚   â”‚   â”œâ”€â”€ character.graphql      # Character domain schema
â”‚   â”‚   â””â”€â”€ killmail.graphql       # Killmail domain schema
â”‚   â”‚
â”‚   â”œâ”€â”€ resolvers/                 # Resolver Implementations
â”‚   â”‚   â”œâ”€â”€ index.ts               # ğŸ”¥ Main file combining all resolvers
â”‚   â”‚   â”œâ”€â”€ user.resolver.ts       # User resolvers (Query + Mutation)
â”‚   â”‚   â”œâ”€â”€ character.resolver.ts  # Character resolvers + Field resolvers
â”‚   â”‚   â””â”€â”€ killmail.resolver.ts   # Killmail resolvers
â”‚   â”‚
â”‚   â”œâ”€â”€ generated-types.ts         # ğŸ¤– Types automatically generated by CodeGen
â”‚   â”œâ”€â”€ generated-schema.graphql   # ğŸ¤– Merged GraphQL schema
â”‚   â””â”€â”€ server.ts                  # GraphQL Yoga server
â”‚
â”œâ”€â”€ codegen.ts                     # GraphQL Code Generator configuration
â”œâ”€â”€ package.json

ğŸ¤– = Automatically generated files (do not edit manually!)
ğŸ”¥ = Critical file
```

---

## ğŸ”„ WORKFLOW STEP BY STEP

### **STEP 1: Schema Definition (Domain-Based)**

Create a separate `.graphql` file for each domain:

#### **user.graphql**

```graphql
type Query {
  user(id: ID!): User
  users: [User!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User
}

type User {
  id: ID!
  name: String!
  email: String!
}
```

#### **character.graphql** (using extend)

```graphql
extend type Query { # âš ï¸ "extend" keyword!
  character(id: ID!): Character
}

extend type Mutation {
  addCharacter(input: AddCharacterInput!): Character!
}

type Character {
  id: ID!
  name: String!
  user: User # Relation field
}
```

**ğŸ’¡ Why use `extend`?**

- To define the same type in multiple files
- Each domain can add its own Query/Mutation
- Merges without conflict

---

### **STEP 2: Code Generation**

```bash
yarn codegen
```

**What happens?**

1. Reads the `codegen.ts` configuration
2. Finds all `src/schema/**/*.graphql` files
3. Merges all schemas â†’ `generated-schema.graphql`
4. Generates TypeScript types â†’ `generated-types.ts`

**Important Generated Types:**

```typescript
// generated-types.ts

export type QueryResolvers = {
  user?: Resolver<...>;
  users?: Resolver<...>;
  character?: Resolver<...>;
  charactersByUser?: Resolver<...>;
  killmail?: Resolver<...>;
  killmails?: Resolver<...>;
};

export type MutationResolvers = {
  createUser?: Resolver<...>;
  updateUser?: Resolver<...>;
  addCharacter?: Resolver<...>;
};

export type CharacterResolvers = {
  user?: Resolver<...>;  // Field resolver
};
```

---

### **STEP 3: Modular Resolver Implementation**

A separate resolver file for each domain:

#### **user.resolver.ts**

```typescript
import { QueryResolvers, MutationResolvers } from "../generated-types";

// Query Resolvers - Exported
export const userQueries: QueryResolvers = {
  user: (_, { id }) => {
    // Fetch user from database
    return findUserById(id);
  },
  users: () => {
    // Fetch all users
    return findAllUsers();
  },
};

// Mutation Resolvers - Exported
export const userMutations: MutationResolvers = {
  createUser: (_, { input }) => {
    // Create new user
    return createNewUser(input);
  },
  updateUser: (_, { id, input }) => {
    // Update user
    return updateExistingUser(id, input);
  },
};
```

**ğŸ’¡ Advantages:**

- âœ… Each domain in its own file (ideal 50-200 lines)
- âœ… Type-safe (TypeScript auto-completion)
- âœ… Testable (each resolver exported separately)
- âœ… Very low risk of merge conflict (work in different files)

---

#### **character.resolver.ts** (With Field Resolvers)

```typescript
import {
  QueryResolvers,
  MutationResolvers,
  CharacterResolvers,
} from "../generated-types";

export const characterQueries: QueryResolvers = {
  character: (_, { id }) => {
    return findCharacterById(id);
  },
};

export const characterMutations: MutationResolvers = {
  addCharacter: (_, { input }) => {
    return createCharacter(input);
  },
};

// ğŸ”¥ FIELD RESOLVER - For nested fields
export const characterFieldResolvers: CharacterResolvers = {
  // Runs when Character.user field is called
  user: (parent) => {
    // parent = Character object
    return findUserById(parent.userId);
  },
};
```

**ğŸ’¡ What is a Field Resolver?**

Query:

```graphql
query {
  character(id: "1") {
    id
    name
    user {
      # â† When this field is called
      name #   characterFieldResolvers.user runs
      email
    }
  }
}
```

Flow:

1. `characterQueries.character` â†’ Returns Character
2. GraphQL sees the `user` field
3. `characterFieldResolvers.user(parent)` is called
4. Fetches User with userId from parent

---

### **STEP 4: Combining Resolvers**

#### **resolvers/index.ts** (Main Combining File)

```typescript
import { Resolvers } from "../generated-types";
import { userQueries, userMutations } from "./user.resolver";
import {
  characterQueries,
  characterMutations,
  characterFieldResolvers,
} from "./character.resolver";
import { killmailQueries } from "./killmail.resolver";

export const resolvers: Resolvers = {
  Query: {
    // Combine all domain queries
    ...userQueries,
    ...characterQueries,
    ...killmailQueries,
  },

  Mutation: {
    // Combine all domain mutations
    ...userMutations,
    ...characterMutations,
  },

  // Field Resolvers
  Character: characterFieldResolvers,
};
```

**ğŸ’¡ Using the Spread Operator (`...`):**

These two codes are the same:

```typescript
// Manual
Query: {
  user: userQueries.user,
  users: userQueries.users,
  character: characterQueries.character,
}

// With spread
Query: {
  ...userQueries,
  ...characterQueries,
}
```

---

### **STEP 5: Connecting to the Server**

#### **server.ts**

```typescript
import { resolvers } from "./resolvers"; // Comes from index.ts

const schema = makeExecutableSchema({
  typeDefs, // Merged from all .graphql files
  resolvers, // From resolvers/index.ts
});

const yoga = createYoga({ schema });
```

---

## âš™ï¸ ADDING A NEW DOMAIN

Example: Let's add a **Post** domain

### 1. Create Schema

**schema/post.graphql**

```graphql
extend type Query {
  post(id: ID!): Post
  posts: [Post!]!
}

extend type Mutation {
  createPost(input: CreatePostInput!): Post!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User # Relation
}

input CreatePostInput {
  title: String!
  content: String!
  authorId: ID!
}
```

### 2. Run CodeGen

```bash
yarn codegen
```

### 3. Create Resolver

**resolvers/post.resolver.ts**

```typescript
import {
  QueryResolvers,
  MutationResolvers,
  PostResolvers,
} from "../generated-types";

export const postQueries: QueryResolvers = {
  post: (_, { id }) => findPostById(id),
  posts: () => findAllPosts(),
};

export const postMutations: MutationResolvers = {
  createPost: (_, { input }) => createNewPost(input),
};

export const postFieldResolvers: PostResolvers = {
  author: (parent) => findUserById(parent.authorId),
};
```

### 4. Add to Index

**resolvers/index.ts**

```typescript
import {
  postQueries,
  postMutations,
  postFieldResolvers,
} from "./post.resolver";

export const resolvers: Resolvers = {
  Query: {
    ...userQueries,
    ...characterQueries,
    ...killmailQueries,
    ...postQueries, // â† Newly added
  },

  Mutation: {
    ...userMutations,
    ...characterMutations,
    ...postMutations, // â† Newly added
  },

  Character: characterFieldResolvers,
  Post: postFieldResolvers, // â† Newly added
};
```

### 5. Restart the Server

```bash
yarn dev
```

âœ… New domain is ready! Without breaking any existing files.

---

## ğŸ¯ BEST PRACTICES

### âœ… DO

1. **Separate file for each domain:**

   - `user.graphql` + `user.resolver.ts`
   - `character.graphql` + `character.resolver.ts`

2. **Small, focused resolvers:**

   - Each resolver does one thing
   - 50-200 lines is ideal

3. **Use field resolvers:**

   - For nested data (solve N+1 query with DataLoader)

4. **Maintain type safety:**

   - Import from `generated-types.ts`
   - Do not use `any`

5. **Use spread operator:**
   - `...userQueries` for clean code

### âŒ DON'T

1. **Don't use a single resolver.ts:**

   - 1000+ line files are unreadable

2. **Don't edit generated-\*.ts files:**

   - CodeGen will overwrite every time

3. **Don't define schema in TypeScript:**

   - Use SDL (`.graphql`), it's more readable

4. **Don't forget field resolvers:**
   - Important for relations

---

## ğŸš€ PERFORMANCE TIPS

### N+1 Query Problem

**Bad Example:**

```typescript
Character: {
  user: (parent) => {
    // Separate query for each character!
    return db.user.findById(parent.userId); // âŒ N+1 problem
  };
}
```

**Good Example (with DataLoader):**

```typescript
import DataLoader from "dataloader";

const userLoader = new DataLoader((ids) =>
  db.user.findMany({ where: { id: { in: ids } } })
);

Character: {
  user: (parent) => {
    return userLoader.load(parent.userId); // âœ… Batch query
  };
}
```

---

## ğŸ“Š FILE SIZE COMPARISON

### Single File Approach âŒ

```
resolvers.ts â†’ 2500 lines
schema.graphql â†’ 800 lines
```

- Hard to read
- High risk of merge conflict
- Hard to test

### Modular Approach âœ…

```
user.graphql â†’ 50 lines
user.resolver.ts â†’ 80 lines

character.graphql â†’ 60 lines
character.resolver.ts â†’ 100 lines

killmail.graphql â†’ 70 lines
killmail.resolver.ts â†’ 120 lines

index.ts â†’ 40 lines
```

- Easy to read
- Low risk of merge conflict
- Easy to test
- Efficient teamwork

---

## ğŸ” SUMMARY OF THE SUMMARY

1. **Schemas â†’ Separate by domain** (user.graphql, character.graphql)
2. **Resolvers â†’ Separate by domain** (user.resolver.ts, character.resolver.ts)
3. **Run CodeGen** â†’ Generate type-safe types
4. **resolvers/index.ts â†’ Combine everything**
5. **server.ts â†’ Schema + Resolver â†’ GraphQL Yoga**

**Result:** Scalable, maintainable, type-safe GraphQL API! ğŸ‰
