type KillmailEdge {
  node: Killmail!
  cursor: String!
}

type KillmailConnection {
  edges: [KillmailEdge!]!
  pageInfo: PageInfo!
}

type KillmailDateCount {
  date: String!
  count: Int!
}

input SyncMyKillmailsInput {
  clientMutationId: String
}

type SyncMyKillmailsPayload {
  success: Boolean!
  message: String!
  syncedCount: Int!
  clientMutationId: String
}

type Killmail {
  id: ID!
  killmailHash: String!
  killmailTime: String!
  solarSystem: SolarSystem!
  victim: Victim
  attackers: [Attacker!]!
  items: [KillmailItem!]!
  fitting: Fitting
  totalValue: Float
  createdAt: String!
}

type Victim {
  character: Character
  corporation: Corporation!
  alliance: Alliance
  factionId: Int
  shipType: Type!
  damageTaken: Int!
  position: Position
}

type Position {
  x: Float!
  y: Float!
  z: Float!
}

type Attacker {
  character: Character
  corporation: Corporation
  alliance: Alliance
  factionId: Int
  shipType: Type
  weaponType: Type
  damageDone: Int!
  finalBlow: Boolean!
  securityStatus: Float
}

type KillmailItem {
  itemType: Type!
  flag: Int!
  quantityDropped: Int
  quantityDestroyed: Int
  singleton: Int!
  charge: KillmailItem
}

"""
Organized fitting data for a ship
Groups modules, rigs, and subsystems by their slot types
"""
type Fitting {
  highSlots: SlotGroup!
  midSlots: SlotGroup!
  lowSlots: SlotGroup!
  rigs: ModuleGroup!
  subsystems: [FittingModule!]!
  cargo: [FittingModule!]!
  droneBay: [FittingModule!]!
  fighterBay: [FittingModule!]!
}

"""
A group of slots with total slot count from dogma attributes
"""
type SlotGroup {
  totalSlots: Int!
  slots: [FittingSlot!]!
}

"""
A group of modules (rigs) with total slot count from dogma attributes
"""
type ModuleGroup {
  totalSlots: Int!
  modules: [FittingModule!]!
}

"""
Represents a single slot (e.g., High Slot 0)
Contains the module fitted in that slot and its charge (if any)
"""
type FittingSlot {
  slotIndex: Int!
  module: FittingModule
}

"""
Represents a fitted module or item
"""
type FittingModule {
  itemType: Type!
  flag: Int!
  quantityDropped: Int
  quantityDestroyed: Int
  singleton: Int!
  charge: FittingModule
}

input KillmailFilter {
  page: Int
  limit: Int
  orderBy: KillmailOrderBy
  search: String
  shipTypeId: Int
  regionId: Int
  systemId: Int
}

enum KillmailOrderBy {
  timeDesc
  timeAsc
}

extend type Query {
  """
  Fetches a single killmail
  """
  killmail(id: ID!): Killmail

  """
  Lists all killmails (with pagination using Relay-style connection)
  """
  killmails(filter: KillmailFilter): KillmailConnection!

  """
  Returns count of killmails grouped by date (for the current filter)
  """
  killmailsDateCounts(filter: KillmailFilter): [KillmailDateCount!]!

  """
  Fetches killmails for a specific character
  """
  characterKillmails(
    characterId: Int!
    first: Int
    after: String
  ): KillmailConnection!

  """
  Fetches killmails for a specific corporation
  """
  corporationKillmails(
    corporationId: Int!
    first: Int
    after: String
  ): KillmailConnection!

  """
  Fetches killmails for a specific alliance
  """
  allianceKillmails(
    allianceId: Int!
    first: Int
    after: String
  ): KillmailConnection!

  """
  Fetches the authenticated user's own killmails
  Requires: Authentication
  """
  myKillmails(limit: Int): [Killmail!]!

  """
  Fetches the authenticated user's corporation killmails
  Requires: Authentication + esi-killmails.read_corporation_killmails.v1 scope
  """
  myCorporationKillmails(limit: Int): [Killmail!]!
}

extend type Mutation {
  """
  Fetches user's killmails from ESI and saves to database
  Requires: Authentication
  """
  syncMyKillmails(input: SyncMyKillmailsInput!): SyncMyKillmailsPayload!
}

extend type Subscription {
  """
  Subscribe to new killmails as they are added to the database
  Emits a new event whenever a killmail is saved
  """
  newKillmail: Killmail!
}
