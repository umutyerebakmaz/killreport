type ActiveUsersPayload {
  count: Int!
  timestamp: String!
}

type Alliance {
  corporationCount: Int!
  corporations: [Corporation!]!
  createdBy: Character
  createdByCorporation: Corporation
  date_founded: String!
  executor: Corporation
  faction_id: Int
  id: Int!
  memberCount: Int!
  metrics: AllianceMetrics
  name: String!
  snapshots(days: Int): [AllianceSnapshot!]!
  ticker: String!
}

input AllianceFilter {
  dateFoundedFrom: String
  dateFoundedTo: String
  limit: Int
  name: String
  orderBy: AllianceOrderBy
  page: Int
  search: String
  ticker: String
}

type AllianceMetrics {
  corporationCountDelta1d: Int
  corporationCountDelta7d: Int
  corporationCountDelta30d: Int
  corporationCountGrowthRate1d: Float
  corporationCountGrowthRate7d: Float
  corporationCountGrowthRate30d: Float
  memberCountDelta1d: Int
  memberCountDelta7d: Int
  memberCountDelta30d: Int
  memberCountGrowthRate1d: Float
  memberCountGrowthRate7d: Float
  memberCountGrowthRate30d: Float
}

enum AllianceOrderBy {
  memberCountAsc
  memberCountDesc
  nameAsc
  nameDesc
}

type AllianceSnapshot {
  corporationCount: Int!
  date: String!
  memberCount: Int!
}

type AlliancesResponse {
  items: [Alliance!]!
  pageInfo: PageInfo!
}

type Attacker {
  alliance: Alliance
  character: Character
  corporation: Corporation
  damageDone: Int!
  factionId: Int
  finalBlow: Boolean!
  securityStatus: Float
  shipType: Type
  weaponType: Type
}

type AuthPayload {
  """JWT access token"""
  accessToken: String!

  """Token geçerlilik süresi (saniye)"""
  expiresIn: Int!

  """Token yenilemek için kullanılan refresh token"""
  refreshToken: String

  """Authenticated kullanıcı bilgileri"""
  user: User!
}

type AuthUrl {
  """CSRF koruması için state parametresi"""
  state: String!

  """Eve Online SSO authorization URL'i"""
  url: String!
}

type Bloodline {
  description: String
  id: Int!
  name: String!
  race: Race!
}

type CacheOperation {
  deletedKeys: Int
  message: String!
  success: Boolean!
}

type CacheStats {
  allianceDetailKeys: Int!
  characterDetailKeys: Int!
  corporationDetailKeys: Int!
  isHealthy: Boolean!
  killmailDetailKeys: Int!
  memoryUsage: String!
  responseCacheKeys: Int!
  totalKeys: Int!
}

type CategoriesResponse {
  items: [Category!]!
  pageInfo: PageInfo!
}

type Category {
  created_at: String!
  groups: [ItemGroup!]!
  id: Int!
  name: String!
  published: Boolean!
  updated_at: String!
}

input CategoryFilter {
  limit: Int
  page: Int
  published: Boolean
  search: String
}

type Character {
  alliance: Alliance
  birthday: String!
  bloodline: Bloodline
  corporation: Corporation
  description: String
  faction_id: Int
  gender: String!
  id: Int!
  name: String!
  race: Race
  security_status: Float
  title: String
  updatedAt: String
}

input CharacterFilter {
  allianceId: Int
  corporationId: Int
  limit: Int
  name: String
  orderBy: CharacterOrderBy
  page: Int
  search: String
}

enum CharacterOrderBy {
  nameAsc
  nameDesc
  securityStatusAsc
  securityStatusDesc
}

type CharactersResponse {
  items: [Character!]!
  pageInfo: PageInfo!
}

type Constellation {
  id: Int!
  name: String!
  position: Position
  region: Region
  securityStats: SecurityStats!
  solarSystemCount: Int!
  solarSystems: [SolarSystem!]!
}

input ConstellationFilter {
  limit: Int
  name: String
  orderBy: ConstellationOrderBy
  page: Int
  region_id: Int
  search: String
}

enum ConstellationOrderBy {
  nameAsc
  nameDesc
}

type ConstellationsResponse {
  items: [Constellation!]!
  pageInfo: PageInfo!
}

type Corporation {
  alliance: Alliance
  ceo: Character
  creator: Character
  date_founded: String
  faction_id: Int
  id: Int!
  member_count: Int!
  metrics: CorporationMetrics
  name: String!
  snapshots(days: Int): [CorporationSnapshot!]!
  tax_rate: Float!
  ticker: String!
  url: String
}

input CorporationFilter {
  allianceId: Int
  dateFoundedFrom: String
  dateFoundedTo: String
  limit: Int
  name: String
  orderBy: CorporationOrderBy
  page: Int
  search: String
  ticker: String
}

type CorporationMetrics {
  memberCountDelta1d: Int
  memberCountDelta7d: Int
  memberCountDelta30d: Int
  memberCountGrowthRate1d: Float
  memberCountGrowthRate7d: Float
  memberCountGrowthRate30d: Float
}

enum CorporationOrderBy {
  memberCountAsc
  memberCountDesc
  nameAsc
  nameDesc
}

type CorporationSnapshot {
  date: String!
  memberCount: Int!
}

type CorporationsResponse {
  items: [Corporation!]!
  pageInfo: PageInfo!
}

input CreateUserInput {
  clientMutationId: String
  email: String!
  name: String!
}

type CreateUserPayload {
  clientMutationId: String
  user: User
}

type DogmaAttribute {
  created_at: String!
  default_value: Float
  description: String
  display_name: String
  high_is_good: Boolean!
  icon_id: Int
  id: Int!
  name: String!
  published: Boolean!
  stackable: Boolean!
  unit_id: Int
  updated_at: String!
}

input DogmaAttributeFilter {
  limit: Int
  page: Int
  published: Boolean
  search: String
}

type DogmaAttributesResponse {
  items: [DogmaAttribute!]!
  pageInfo: PageInfo!
}

type DogmaEffect {
  created_at: String!
  description: String
  disallow_auto_repeat: Boolean!
  display_name: String
  effect_category: Int
  icon_id: Int
  id: Int!
  is_assistance: Boolean!
  is_offensive: Boolean!
  name: String!
  post_expression: Int
  pre_expression: Int
  published: Boolean!
  updated_at: String!
}

input DogmaEffectFilter {
  effect_category: Int
  limit: Int
  page: Int
  published: Boolean
  search: String
}

type DogmaEffectsResponse {
  items: [DogmaEffect!]!
  pageInfo: PageInfo!
}

"""
Organized fitting data for a ship
Groups modules, rigs, and subsystems by their slot types
"""
type Fitting {
  cargo: [FittingModule!]!
  coreRoom: [FittingModule!]!
  droneBay: [FittingModule!]!
  fighterBay: [FittingModule!]!
  highSlots: SlotGroup!
  implants: SlotGroup!
  lowSlots: SlotGroup!
  midSlots: SlotGroup!
  rigs: SlotGroup!
  serviceSlots: SlotGroup!
  structureFuel: [FittingModule!]!
  subsystems: SlotGroup!
}

"""Represents a fitted module or item"""
type FittingModule {
  charge: FittingModule
  flag: Int!
  itemType: Type!
  quantityDestroyed: Int
  quantityDropped: Int
  singleton: Int!
}

"""
Represents a single slot (e.g., High Slot 0)
Contains the module fitted in that slot and its charge (if any)
"""
type FittingSlot {
  module: FittingModule
  slotIndex: Int!
}

type ItemGroup {
  category: Category!
  created_at: String!
  id: Int!
  name: String!
  published: Boolean!
  types: [Type!]!
  updated_at: String!
}

input ItemGroupFilter {
  category_id: Int
  limit: Int
  page: Int
  published: Boolean
  search: String
}

type ItemGroupsResponse {
  items: [ItemGroup!]!
  pageInfo: PageInfo!
}

type JitaPrice {
  """Average of buy and sell"""
  average: Float!

  """Highest buy order (instant sell price)"""
  buy: Float!

  """Lowest sell order (instant buy price)"""
  sell: Float!

  """Data source timestamp"""
  updatedAt: String!

  """Total market volume"""
  volume: Float
}

type Killmail {
  attackerCount: Int!
  attackers: [Attacker!]!
  createdAt: String!
  destroyedValue: Float
  droppedValue: Float
  finalBlow: Attacker
  fitting: Fitting
  id: ID!
  items: [KillmailItem!]!
  killmailHash: String!
  killmailTime: String!
  npc: Boolean!
  solarSystem: SolarSystem!
  solo: Boolean!
  totalValue: Float
  victim: Victim
}

type KillmailDateCount {
  count: Int!
  date: String!
}

input KillmailFilter {
  allianceId: Int
  characterId: Int
  corporationId: Int
  limit: Int
  orderBy: KillmailOrderBy
  page: Int
  regionId: Int
  search: String
  shipTypeId: Int
  systemId: Int
}

type KillmailItem {
  charge: KillmailItem
  flag: Int!
  itemType: Type!
  quantityDestroyed: Int
  quantityDropped: Int
  singleton: Int!
}

enum KillmailOrderBy {
  timeAsc
  timeDesc
}

type KillmailsResponse {
  items: [Killmail!]!
  pageInfo: PageInfo!
}

type Mutation {
  _empty: String

  """Authorization code ile authentication yapar ve token döner"""
  authenticateWithCode(code: String!, state: String!): AuthPayload!

  """Clear all killmail caches (use after large data updates)"""
  clearAllKillmailCaches: CacheOperation!

  """Clear cache for a specific alliance"""
  clearAllianceCache(allianceId: Int!): CacheOperation!

  """Clear cache for a specific character"""
  clearCharacterCache(characterId: Int!): CacheOperation!

  """Clear cache for a specific corporation"""
  clearCorporationCache(corporationId: Int!): CacheOperation!

  """Clear cache for a specific killmail"""
  clearKillmailCache(killmailId: Int!): CacheOperation!
  createUser(input: CreateUserInput!): CreateUserPayload!

  """Eve Online SSO login için authorization URL'i oluşturur"""
  login: AuthUrl!
  refreshCharacter(characterId: Int!): RefreshCharacterResult!

  """Refresh token kullanarak yeni access token alır"""
  refreshToken(refreshToken: String!): AuthPayload!
  startAllianceSync(input: StartAllianceSyncInput!): StartAllianceSyncPayload!
  startCategorySync(input: StartCategorySyncInput!): StartCategorySyncPayload!
  startConstellationSync(input: StartConstellationSyncInput!): StartConstellationSyncPayload!
  startDogmaAttributeSync(input: StartDogmaAttributeSyncInput!): StartDogmaAttributeSyncPayload!
  startDogmaEffectSync(input: StartDogmaEffectSyncInput!): StartDogmaEffectSyncPayload!
  startItemGroupSync(input: StartItemGroupSyncInput!): StartItemGroupSyncPayload!
  startRegionSync(input: StartRegionSyncInput!): StartRegionSyncPayload!
  startTypeDogmaSync(input: StartTypeDogmaSyncInput!): StartTypeDogmaSyncPayload!
  startTypeSync(input: StartTypeSyncInput!): StartTypeSyncPayload!

  """
  Fetches user's killmails from ESI and saves to database
  Requires: Authentication
  """
  syncMyKillmails(input: SyncMyKillmailsInput!): SyncMyKillmailsPayload!
  updateUser(input: UpdateUserInput!): UpdateUserPayload!
}

"""Offset-based pagination info (page number + limit)"""
type PageInfo {
  currentPage: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalCount: Int!
  totalPages: Int!
}

type Position {
  x: Float!
  y: Float!
  z: Float!
}

type Query {
  _empty: String
  activeUsersCount: Int!
  alliance(id: Int!): Alliance
  alliances(filter: AllianceFilter): AlliancesResponse!
  bloodline(id: Int!): Bloodline
  bloodlines: [Bloodline!]!

  """Cache statistics and memory usage"""
  cacheStats: CacheStats!
  categories(filter: CategoryFilter): CategoriesResponse!
  category(id: Int!): Category
  character(id: Int!): Character
  characters(filter: CharacterFilter): CharactersResponse!
  constellation(id: Int!): Constellation
  constellations(filter: ConstellationFilter): ConstellationsResponse!
  corporation(id: Int!): Corporation
  corporations(filter: CorporationFilter): CorporationsResponse!
  dogmaAttribute(id: Int!): DogmaAttribute
  dogmaAttributes(filter: DogmaAttributeFilter): DogmaAttributesResponse!
  dogmaEffect(id: Int!): DogmaEffect
  dogmaEffects(filter: DogmaEffectFilter): DogmaEffectsResponse!
  itemGroup(id: Int!): ItemGroup
  itemGroups(filter: ItemGroupFilter): ItemGroupsResponse!

  """Fetches a single killmail"""
  killmail(id: ID!): Killmail

  """Lists all killmails with pagination"""
  killmails(filter: KillmailFilter): KillmailsResponse!

  """Returns count of killmails grouped by date (for the current filter)"""
  killmailsDateCounts(filter: KillmailFilter): [KillmailDateCount!]!

  """Mevcut authenticated kullanıcının bilgilerini döner"""
  me: User
  race(id: Int!): Race
  races: [Race!]!
  region(id: Int!): Region
  regions(filter: RegionFilter): RegionsResponse!
  solarSystem(id: Int!): SolarSystem
  solarSystems(filter: SolarSystemFilter): SolarSystemsResponse!
  type(id: Int!): Type
  types(filter: TypeFilter): TypesResponse!
  user(id: ID!): User
  users: [User!]!

  """Get current status of all workers and queues"""
  workerStatus: WorkerStatus!
}

type QueueStatus {
  """Is there at least one active consumer"""
  active: Boolean!

  """Number of active consumers processing from this queue"""
  consumerCount: Int!

  """Number of messages waiting to be processed"""
  messageCount: Int!

  """Name of the queue"""
  name: String!

  """Worker script name (e.g., worker:info:corporations)"""
  workerName: String

  """Process ID of the running worker"""
  workerPid: Int

  """Is the worker process running (detected via ps aux)"""
  workerRunning: Boolean!
}

type Race {
  description: String
  id: Int!
  name: String!
}

type RedisMetrics {
  """Commands processed per second (instantaneous)"""
  commandsPerSecond: Int!

  """Redis connection status"""
  connected: Boolean!

  """Connected clients count"""
  connectedClients: Int!

  """Redis memory usage (human readable)"""
  memoryUsage: String!

  """Total commands processed"""
  totalCommandsProcessed: Int!

  """Number of keys in Redis"""
  totalKeys: Int!

  """Redis uptime in seconds"""
  uptimeInSeconds: Int!
}

type RefreshCharacterResult {
  characterId: Int!
  message: String!
  queued: Boolean!
  success: Boolean!
}

type Region {
  constellationCount: Int!
  constellations: [Constellation!]!
  description: String
  id: Int!
  name: String!
  securityStats: SecurityStats!
  solarSystemCount: Int!
}

input RegionFilter {
  limit: Int
  name: String
  orderBy: RegionOrderBy
  page: Int
  search: String
}

enum RegionOrderBy {
  nameAsc
  nameDesc
}

type RegionsResponse {
  items: [Region!]!
  pageInfo: PageInfo!
}

type SecurityStats {
  avgSecurity: Float
  highSec: Int!
  lowSec: Int!
  nullSec: Int!
  wormhole: Int!
}

"""A group of slots with total slot count from dogma attributes"""
type SlotGroup {
  slots: [FittingSlot!]!
  totalSlots: Int!
}

type SolarSystem {
  constellation: Constellation
  id: Int!
  name: String!
  position: Position
  security_class: String
  security_status: Float
  star_id: Int
}

input SolarSystemFilter {
  constellation_id: Int
  limit: Int
  name: String
  orderBy: SolarSystemOrderBy
  page: Int
  region_id: Int
  search: String
  securityStatusMax: Float
  securityStatusMin: Float
}

enum SolarSystemOrderBy {
  nameAsc
  nameDesc
  securityStatusAsc
  securityStatusDesc
}

type SolarSystemsResponse {
  items: [SolarSystem!]!
  pageInfo: PageInfo!
}

type StandaloneWorkerStatus {
  """Description of what this worker does"""
  description: String!

  """Name of the worker"""
  name: String!

  """Process ID if running"""
  pid: Int

  """Is the worker currently running"""
  running: Boolean!
}

input StartAllianceSyncInput {
  clientMutationId: String
}

type StartAllianceSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartCategorySyncInput {
  clientMutationId: String
}

type StartCategorySyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartConstellationSyncInput {
  clientMutationId: String
}

type StartConstellationSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartDogmaAttributeSyncInput {
  clientMutationId: String
}

type StartDogmaAttributeSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartDogmaEffectSyncInput {
  clientMutationId: String
}

type StartDogmaEffectSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartItemGroupSyncInput {
  clientMutationId: String
}

type StartItemGroupSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartRegionSyncInput {
  clientMutationId: String
}

type StartRegionSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

input StartTypeDogmaSyncInput {
  clientMutationId: String
  typeIds: [Int!]
}

type StartTypeDogmaSyncPayload {
  clientMutationId: String
  message: String
  queuedCount: Int
  success: Boolean!
}

input StartTypeSyncInput {
  clientMutationId: String
}

type StartTypeSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

type Subscription {
  _empty: String
  activeUsersUpdates: ActiveUsersPayload!

  """
  Subscribe to new killmails as they are added to the database
  Emits a new event whenever a killmail is saved
  """
  newKillmail: Killmail!

  """
  Subscribe to real-time worker status updates
  Emits updates every 5 seconds
  """
  workerStatusUpdates: WorkerStatus!
}

input SyncMyKillmailsInput {
  clientMutationId: String
}

type SyncMyKillmailsPayload {
  clientMutationId: String
  message: String!
  success: Boolean!
  syncedCount: Int!
}

type Type {
  capacity: Float
  created_at: String!
  description: String
  dogmaAttributes(ids: [Int!]): [TypeDogmaAttribute!]!
  dogmaEffects(ids: [Int!]): [TypeDogmaEffect!]!
  group: ItemGroup
  icon_id: Int
  id: Int!

  """Jita market price (cached, updates every 4 hours)"""
  jitaPrice: JitaPrice
  mass: Float
  name: String!
  published: Boolean!
  updated_at: String!
  volume: Float
}

type TypeDogmaAttribute {
  attribute: DogmaAttribute!
  attribute_id: Int!
  type_id: Int!
  value: Float!
}

type TypeDogmaEffect {
  effect: DogmaEffect!
  effect_id: Int!
  is_default: Boolean!
  type_id: Int!
}

input TypeFilter {
  categoryList: [Int!]
  groupList: [Int!]
  group_id: Int
  limit: Int
  name: String
  page: Int
  published: Boolean
}

type TypesResponse {
  items: [Type!]!
  pageInfo: PageInfo!
}

input UpdateUserInput {
  clientMutationId: String
  email: String
  id: ID!
  name: String
}

type UpdateUserPayload {
  clientMutationId: String
  user: User
}

type User {
  createdAt: String!
  email: String!
  id: ID!
  name: String!
}

type Victim {
  alliance: Alliance
  character: Character
  corporation: Corporation
  damageTaken: Int!
  factionId: Int
  position: Position
  shipType: Type!
}

type WorkerStatus {
  """Database size in megabytes (MB)"""
  databaseSizeMB: Float!

  """Overall system health"""
  healthy: Boolean!

  """Status of individual queues (RabbitMQ-based workers)"""
  queues: [QueueStatus!]!

  """Redis server metrics"""
  redis: RedisMetrics

  """Status of standalone workers (non-RabbitMQ)"""
  standaloneWorkers: [StandaloneWorkerStatus!]!

  """Timestamp of the status check"""
  timestamp: String!
}