type Alliance {
  corporationCount: Int!
  corporations: [Corporation!]
  createdBy: Character
  createdByCorporation: Corporation
  creator_corporation_id: Int!
  creator_id: Int!
  date_founded: String!
  executor: Corporation
  executor_corporation_id: Int!
  faction_id: Int
  id: Int!
  memberCount: Int!
  metrics: AllianceMetrics
  name: String!
  snapshots(days: Int): [AllianceSnapshot!]!
  ticker: String!
}

type AllianceConnection {
  edges: [AllianceEdge!]!
  pageInfo: PageInfo!
}

type AllianceEdge {
  cursor: String!
  node: Alliance!
}

input AllianceFilter {
  dateFoundedFrom: String
  dateFoundedTo: String
  limit: Int
  name: String
  orderBy: AllianceOrderBy
  page: Int
  search: String
  ticker: String
}

type AllianceMetrics {
  corporationCountDelta1d: Int
  corporationCountDelta7d: Int
  corporationCountDelta30d: Int
  corporationCountGrowthRate1d: Float
  corporationCountGrowthRate7d: Float
  corporationCountGrowthRate30d: Float
  memberCountDelta1d: Int
  memberCountDelta7d: Int
  memberCountDelta30d: Int
  memberCountGrowthRate1d: Float
  memberCountGrowthRate7d: Float
  memberCountGrowthRate30d: Float
}

enum AllianceOrderBy {
  memberCountAsc
  memberCountDesc
  nameAsc
  nameDesc
}

type AllianceSnapshot {
  corporationCount: Int!
  date: String!
  memberCount: Int!
}

type Attacker {
  allianceId: Int
  allianceName: String
  characterId: Int
  characterName: String
  corporationId: Int
  corporationName: String
  damageDone: Int!
  factionId: Int
  finalBlow: Boolean!
  securityStatus: Float!
  shipTypeId: Int
  shipTypeName: String
  weaponTypeId: Int
  weaponTypeName: String
}

type AuthPayload {
  """JWT access token"""
  accessToken: String!

  """Token geçerlilik süresi (saniye)"""
  expiresIn: Int!

  """Token yenilemek için kullanılan refresh token"""
  refreshToken: String

  """Authenticated kullanıcı bilgileri"""
  user: User!
}

type AuthUrl {
  """CSRF koruması için state parametresi"""
  state: String!

  """Eve Online SSO authorization URL'i"""
  url: String!
}

type Character {
  alliance: Alliance
  alliance_id: Int
  birthday: String!
  bloodline_id: Int!
  corporation: Corporation
  corporation_id: Int!
  description: String
  faction_id: Int
  gender: String!
  id: Int!
  name: String!
  race_id: Int!
  security_status: Float
  title: String
}

type CharacterConnection {
  edges: [CharacterEdge!]!
  pageInfo: PageInfo!
}

type CharacterEdge {
  cursor: String!
  node: Character!
}

input CharacterFilter {
  alliance_id: Int
  corporation_id: Int
  limit: Int
  name: String
  orderBy: CharacterOrderBy
  page: Int
  search: String
}

enum CharacterOrderBy {
  nameAsc
  nameDesc
  securityStatusAsc
  securityStatusDesc
}

type Corporation {
  alliance: Alliance
  alliance_id: Int
  ceo: Character
  ceo_id: Int!
  creator: Character
  creator_id: Int!
  date_founded: String
  faction_id: Int
  id: Int!
  member_count: Int!
  metrics: CorporationMetrics
  name: String!
  snapshots(days: Int): [CorporationSnapshot!]!
  tax_rate: Float!
  ticker: String!
  url: String
}

type CorporationConnection {
  edges: [CorporationEdge!]!
  pageInfo: PageInfo!
}

type CorporationEdge {
  cursor: String!
  node: Corporation!
}

input CorporationFilter {
  allianceId: Int
  dateFoundedFrom: String
  dateFoundedTo: String
  limit: Int
  name: String
  orderBy: CorporationOrderBy
  page: Int
  search: String
  ticker: String
}

type CorporationMetrics {
  memberCountDelta1d: Int
  memberCountDelta7d: Int
  memberCountDelta30d: Int
  memberCountGrowthRate1d: Float
  memberCountGrowthRate7d: Float
  memberCountGrowthRate30d: Float
}

enum CorporationOrderBy {
  memberCountAsc
  memberCountDesc
  nameAsc
  nameDesc
}

type CorporationSnapshot {
  date: String!
  memberCount: Int!
}

input CreateUserInput {
  clientMutationId: String
  email: String!
  name: String!
}

type CreateUserPayload {
  clientMutationId: String
  user: User
}

type Killmail {
  attackers: [Attacker!]!
  createdAt: String!
  id: ID!
  items: [KillmailItem!]!
  killmailHash: String!
  killmailId: Int!
  killmailTime: String!
  solarSystemId: Int!
  totalValue: Float
  victim: Victim!
}

type KillmailConnection {
  edges: [KillmailEdge!]!
  pageInfo: PageInfo!
}

type KillmailEdge {
  cursor: String!
  node: Killmail!
}

type KillmailItem {
  flag: Int!
  itemTypeId: Int!
  itemTypeName: String
  quantityDestroyed: Int
  quantityDropped: Int
  singleton: Int!
}

type Mutation {
  _empty: String

  """Authorization code ile authentication yapar ve token döner"""
  authenticateWithCode(code: String!, state: String!): AuthPayload!
  createUser(input: CreateUserInput!): CreateUserPayload!

  """Eve Online SSO login için authorization URL'i oluşturur"""
  login: AuthUrl!

  """Refresh token kullanarak yeni access token alır"""
  refreshToken(refreshToken: String!): AuthPayload!
  startAllianceSync(input: StartAllianceSyncInput!): StartAllianceSyncPayload!

  """
  Fetches user's killmails from ESI and saves to database
  Requires: Authentication
  """
  syncMyKillmails(input: SyncMyKillmailsInput!): SyncMyKillmailsPayload!
  updateUser(input: UpdateUserInput!): UpdateUserPayload!
}

type PageInfo {
  currentPage: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  nextCursor: Int
  previousCursor: Int
  totalCount: Int!
  totalPages: Int!
}

type Position {
  x: Float!
  y: Float!
  z: Float!
}

type Query {
  _empty: String
  alliance(id: Int!): Alliance
  alliances(filter: AllianceFilter): AllianceConnection!
  character(id: Int!): Character
  characters(filter: CharacterFilter): CharacterConnection!
  corporation(id: Int!): Corporation
  corporations(filter: CorporationFilter): CorporationConnection!

  """Fetches a single killmail"""
  killmail(id: ID!): Killmail

  """Lists all killmails (with pagination using Relay-style connection)"""
  killmails(after: String, first: Int): KillmailConnection!

  """Mevcut authenticated kullanıcının bilgilerini döner"""
  me: User

  """
  Fetches the authenticated user's corporation killmails
  Requires: Authentication + esi-killmails.read_corporation_killmails.v1 scope
  """
  myCorporationKillmails(limit: Int): [Killmail!]!

  """
  Fetches the authenticated user's own killmails
  Requires: Authentication
  """
  myKillmails(limit: Int): [Killmail!]!
  user(id: ID!): User
  users: [User!]!

  """Get current status of all workers and queues"""
  workerStatus: WorkerStatus!
}

type QueueStatus {
  """Is the queue currently active"""
  active: Boolean!

  """Number of messages currently being processed"""
  consumerCount: Int!

  """Number of messages waiting to be processed"""
  messageCount: Int!

  """Name of the queue"""
  name: String!
}

input StartAllianceSyncInput {
  clientMutationId: String
}

type StartAllianceSyncPayload {
  clientMutationId: String
  message: String
  success: Boolean!
}

type Subscription {
  _empty: String

  """
  Subscribe to real-time worker status updates
  Emits updates every 5 seconds
  """
  workerStatusUpdates: WorkerStatus!
}

input SyncMyKillmailsInput {
  clientMutationId: String
}

type SyncMyKillmailsPayload {
  clientMutationId: String
  message: String!
  success: Boolean!
  syncedCount: Int!
}

input UpdateUserInput {
  clientMutationId: String
  email: String
  id: ID!
  name: String
}

type UpdateUserPayload {
  clientMutationId: String
  user: User
}

type User {
  createdAt: String!
  email: String!
  id: ID!
  name: String!
}

type Victim {
  allianceId: Int
  allianceName: String
  characterId: Int
  characterName: String
  corporationId: Int!
  corporationName: String
  damageTaken: Int!
  factionId: Int
  position: Position
  shipTypeId: Int!
  shipTypeName: String
}

type WorkerStatus {
  """Overall system health"""
  healthy: Boolean!

  """Status of individual queues"""
  queues: [QueueStatus!]!

  """Timestamp of the status check"""
  timestamp: String!
}